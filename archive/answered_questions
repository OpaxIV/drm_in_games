Secproj Fragen 16.10.2023

- Beispiel und Definition von Opaque Predicate
--> Ein klares Ausgehen einer Bedingung, die aber trotzdem zu überprüfen ist.
--> Grundsätzliche Idee ist daher, dass durch das Einfügen immer mehr "unnötiger" Branches der Kontrollfluss an Volumen zunimmt.




-  "Is hides the original code in a sequence of bytes, which are then interpreted at runtime."
--> Was genau ist "bytecode"?
	-->  Anderer Begriff für "machine code"
	--> repräsentiert instruktionen als machinen code
	--> Im Falle einer VM gibt es virtuelle Instruktionen (bspw. virtuelle addition)
	--> Eine VM hat eine eigenständige ISA, die je nach VM also unterschiedlich sein kann.
	--> Der originale Code wird in der VM verschleiert, diese übersetzt den Originalcode in VM assembler / byte repräsentation
	--> Der byte code ist nichts anderes als ein array: es wird eine Funktion nach der anderen (bspw. `d5` an der Adresse  0x104060 ist die erste)
	--> Durch Inkremetierung werden dann im array die nächste(n) Instruktionen geholt, zeigt dann auf nächste intruktion.


- Unterschiedliche Längen der Instruktionen aus dem Bytearray?
	--> Jede Instruktion ist anders und kann daher auch einer anderen bytelänge entsprechen
	--> Beispiel wäre an 0x101262 


- RDX: instruction pointer, wird addiert zur grösse der jetzigen instruction --> ist der wert (ADD rbx 0x5) daher irrelevent? bsp. 001011e1
	--> Der Virtual Intruction Pointer hat nichts mit dem nativen Instruction Pointer zu tun.
	--> Ich habe mich immer gefragt, wieso der Instructionpointer nur manchmal addiert und manchmal nicht. Diesem sollte ja eigentlich immer etwas dazuaddiert werden, sodass er auch auf die neuste Instruktion zeigt.
	--> Da dieser jedoch unabhängig ist, ist alles umso klarer. Hier ein Beispiel:
	--> Wie im Decompiler zu sehen, werden Instruktionen trotzdem weiter ausgeführt, auch wenn der VIP gar nicht angerührt wird:
	```
            virtual_IP = virtual_IP + 1;
            *(uint *)(ppiVar2 + -1) =
                 (uint)(*(uint *)(ppiVar2 + -1) < *(uint *)ppiVar2 ||
                       *(uint *)(ppiVar2 + -1) == *(uint *)ppiVar2);
            ppiVar2 = ppiVar2 + -1;
	```		
			
			
- 001012b9: korrekt, dass der nicht virtuelle stack wiederhergestellt wird?
	--> korrekt, hier geht es um den "nativen" stack.
	--> ergebnis wird in eax geschrieben 
	--> Stack aufgeräumt


- Wie würde eine register based architecure aussehen?

---> register based nicht instruction, register wie x86

- wie weitermachen?
	--> opaque predicate

