# Analysis of the Function at 0x1401f5a12

## Troubleshooting
If for any reason (as in my case), the function is non existant or not recognized by your disassembly program, follow these steps:
Binary Ninja:
- Search and input the address `0x1401f5a12` by hitting "G".
- In the hex view, mark the 48th byte
- Right click on it and choose make function ... -> default
- <img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/66acb7d8-fe1c-4713-b5da-fdf6f75b9356" width="800">
If the above steps did not solve the issue, try "Analysis" --> "Run Linear Sweep"

IDA64:
- Search and input the address `0x1401f5a12` by hitting "G".
- Mark the disassembly (or whatever IDA did at this address), hit "C" to change to code and then "P" to create a function

@ fabio:
additions from tim:
0x1401f5a12 
- cvtsi --> komische instruktionen
- indirect jump


## Table of Contents
1. [Graph View](#graphview)
2. [Control Flow Analysis & Disassembly](#controlflowanalysis)
3. [Type of Obfuscated Code](#typeofobfuscation)
4. [Appendix](#appendix)

## Graph View <a name="graphview"></a>
_Note: In Binary Ninja, choose "Graph" and then "Disassembly" on the toolbar in the middle._
To get a rough overview of the function, a look at the graph view is provided:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/cb6a6cb3-b838-4e30-abce-024197718e5b" width="500">
<br/>
Compared to some other analysed functions, this sample does not really provide a graph as in the "traditional" sense. BinaryNinja presents us one big chunk of disassembly, placed in only one basic block. This is certainly unusual compared to control flow graphs of traditional programs, but also compared to other obfuscated functions.

## Control Flow Analysis & Disassembly <a name="controlflowanalysis"></a>
The flow of this function seems to be pretty linear when looking at the disassembly.
```asm
sub_1401f5a12:
1401f5a12  mov     rcx, 0xfffffffffcc0dfe6
1401f5a1c  lea     rbp, [rel 0x143898714]
1401f5a23  add     rbp, rcx  {sub_1404a66fa}
1401f5a26  call    rbp  {sub_1404a66fa}
1401f5a28  add     rsp, 0x100
1401f5a2f  call    qword [rsp+0x18 {arg2}]
1401f5a36  sub     rsp, 0x100
1401f5a3d  mov     qword [rsp {__return_addr}], rsi
1401f5a41  push    rbp {var_8}  {sub_1404a66fa}
1401f5a42  lea     rsp, [rsp-0x10]
1401f5a4a  mov     rsi, rax
1401f5a4d  mov     rbp, rax
1401f5a50  movups  xmmword [rsp {var_18}], xmm9
1401f5a55  lea     rsp, [rsp-0x10]
1401f5a5d  shr     ebp, 0x6
1401f5a60  xorps   xmm9, xmm9
1401f5a64  movups  xmmword [rsp {__saved_zmm10}], xmm10
1401f5a69  cvtsi2sd xmm9, ebp
1401f5a6e  mov     rbp, 0x3e40000000000000
1401f5a78  movq    xmm10, rbp  {0x3e40000000000000}
1401f5a7d  mulsd   xmm9, xmm10
1401f5a82  movaps  xmm10, xmm9
1401f5a86  mov     rbp, 0xfffffffffc49d603
1401f5a90  mulsd   xmm10, xmm9
1401f5a95  comisd  xmm10, xmm9
1401f5a9a  movups  xmm10, xmmword [rsp {__saved_zmm10}]
1401f5a9f  lea     rsp, [rsp+0x10]
1401f5aa7  movups  xmm9, xmmword [rsp {var_18}]
1401f5aac  lea     rsp, [rsp+0x10]
1401f5ab4  push    rcx {var_18+0x8}
1401f5ab5  mov     rcx, 0xfffffffffc0ad876
1401f5abf  cmovbe  rbp, rcx  {0xfffffffffc0ad876}
1401f5ac3  lea     rcx, [rel 0x144214840]
1401f5aca  lea     rbp, [rbp+rcx]
1401f5acf  shr     esi, 0x5
1401f5ad2  pop     rcx {var_18+0x8}
1401f5ad3  lea     rsp, [rsp-0x10]
1401f5adb  movups  xmmword [rsp], xmm4
1401f5adf  lea     rsp, [rsp-0x10]
1401f5ae7  movups  xmmword [rsp {__saved_zmm10}], xmm2
1401f5aeb  cvtsi2sd xmm4, esi
1401f5aef  mov     rsi, 0x3e40000000000000
1401f5af9  lea     rsp, [rsp-0x10]
1401f5b01  movq    xmm2, rsi  {0x3e40000000000000}
1401f5b06  mulsd   xmm4, xmm2
1401f5b0a  movapd  xmm2, xmm4
1401f5b0e  mov     rsi, 0xbff0000000000000
1401f5b18  addsd   xmm2, xmm4
1401f5b1c  movups  xmmword [rsp {var_38}], xmm0
1401f5b20  movq    xmm0, rsi  {0xbff0000000000000}
1401f5b25  addsd   xmm2, xmm0
1401f5b29  mulsd   xmm2, xmm4
1401f5b2d  addsd   xmm2, xmm0
1401f5b31  mov     rsi, 0xffffffffff69aca6
1401f5b3b  movapd  xmm0, xmm4
1401f5b3f  mulsd   xmm0, xmm4
1401f5b43  ucomisd xmm0, xmm2
1401f5b47  movq    xmm0, r13
1401f5b4c  mov     r13, 0xfffffffffffdf92c
1401f5b56  cmovbe  rsi, r13  {0xfffffffffffdf92c}
1401f5b5a  lea     r13, [rel 0x140aa4154]
1401f5b61  lea     rsi, [rsi+r13]
1401f5b65  movq    r13, xmm0
1401f5b6a  jmp     rsi
```
There are no compare or jump instructions except for the last instruction `jmp     rsi` at `0x1401f5b6a`, which is called an "indirect jump". An indirect jump specifies where the address of the next instruction is located, rather than the address of the next instruction to execute, as in a direct branch. In this case the address of the next instruction to execute would be located in the register `%rsi`. However the address to be jumped to is not known until the instruction is executed.<br>


### Function Exit



## Type of Obfuscated Code <a name="typeofobfuscation"></a>


## Appendix <a name="appendix"></a>
Some further information, not really fitting directly into the text of the analysis:
### Indirect jump:
Depending of the processor architecture, the assembly instruction for an indirect jump looks like the following:
- x86 (AT&T Syntax):      	`jmp *%eax`
- x86 (Intel Syntax):      	`jmp eax`




---
- CSE 351 Section 4 â€“ GDB and x86-64 Assembly - https://courses.cs.washington.edu/courses/cse351/19wi/sections/04/cse351_sec4_soln.pdf
