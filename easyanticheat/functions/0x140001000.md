# Analysis of the Function at 0x140001000
## Graph View
To get a rough overview of the function, a look at the graph view is provided:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/f4bc1469-131c-4bb2-bf3e-ad2fe6733f11" width="500">
<br/>
As one can see, there are multiple branches (conditionals) which might be taken. There are basically two ways the control flow can go: Either by the "construction" on the left with the various conditional jumps, or the right side which is more or less a direct jump to the last basic block `0x140001133`.

## Control Flow Analysis & Disassembly
Besides the usual stack preparations, we can see a conditional jump at `0x140001027`. Either the value located in memory at `[rax]` is equal to `6` (hence the result being 6 - [rax] == 0) or not. A "more direct" jump would only occur if the result is not zero (`jnz     loc_140001131`).
```asm
[...]
.text:0000000140001000 mov     [rsp-8+arg_10], rbx
.text:0000000140001005 mov     [rsp-8+arg_18], rdi
.text:000000014000100A push    rbp
.text:000000014000100B mov     rbp, rsp
.text:000000014000100E sub     rsp, 80h
.text:0000000140001015 xor     edi, edi
.text:0000000140001017 mov     rax, 0FFFFF7800000026Ch
.text:0000000140001021 mov     dword ptr [rbp+arg_0], edi
.text:0000000140001024 cmp     dword ptr [rax], 6
.text:0000000140001027 jnz     loc_140001131
[...]
```
### [rax] == 6
The more complex path is taken, if `[rax]` is equal to the value`6`. 
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/1fa25bfc-51d5-435e-a32f-840455920967" width="500">
<br/>

The "false"-branch is executed, hence leading the path onto the address `0x14000102D`.
```asm
.text:000000014000102D mov     rax, 0FFFFF78000000270h
.text:0000000140001037 lea     ebx, [rdi+1]
.text:000000014000103A cmp     [rax], ebx
.text:000000014000103C jnz     loc_140001131
```
In here we can see that a rather large number `0x0FFFFF7800000027` (suffix removed) is being copied into the register `rax`. Converted into an integer this value would be interchangeable with `1152920920491294759`.
Afterwards some computation is executed by loading the effective address of `[rdi+1]` into `ebx`.
The value in register `ebx` is the compared to the location in memory at `[rax]`. If they do not compute to the same value, hence resulting in `ebx` - `[rax]` != 0, the control flow continues at the address `0x140001131`, the same as in the proceding outermost right branch:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/296e7c5d-bbeb-41d0-a03f-b70924d86f4d" width="500">
<br/>
On the other hand, if the opration `ebx` - `[rax]` is actually equal to zero, then the jump occurs into the basic block that follows at `0x140001042`. In here, some sort of (byte) array is compared to the value in the `dil` register (part of `edi`).
```asm
.text:0000000140001042 cmp     cs:byte_14007B170, dil
.text:0000000140001049 jnz     loc_14000110B
```
Again, if the comparasion does not result in zero, a jump is taken to the basic block at `0x14000110B`. If not, then the control flow gets redirected to the block which follows at  `0x14000104F`.
In the disassembly of this very basic block one can see multiple operations, which seem to be executed in conjunction with an array:
```asm
.text:000000014000104F xor     eax, eax
.text:0000000140001051 mov     [rbp+var_60], 6C86962Eh
.text:0000000140001058 mov     [rbp+var_14], rax
.text:000000014000105C xorps   xmm0, xmm0
.text:000000014000105F mov     [rbp+var_C], eax
.text:0000000140001062 mov     edx, 0C6C6253Ch
.text:0000000140001067 lea     rax, [rbp+var_60]
.text:000000014000106B mov     [rbp+var_5C], 0B04EE3B8h
.text:0000000140001072 mov     [rbp+var_58], 0FEA7766Dh
.text:0000000140001079 mov     [rbp+var_54], 0E0B08383h
.text:0000000140001080 mov     [rbp+var_50], 1EF6C3A5h
.text:0000000140001087 mov     [rbp+var_4C], 19AB09B1h
.text:000000014000108E mov     [rbp+var_48], 0EEBB45CDh
.text:0000000140001095 mov     [rbp+var_44], 34FCA826h
.text:000000014000109C mov     [rbp+var_40], 2B0E76ACh
.text:00000001400010A3 mov     [rbp+var_3C], 50392963h
.text:00000001400010AA mov     [rbp+var_38], 5B1B5245h
.text:00000001400010B1 movups  [rbp+var_34], xmm0
.text:00000001400010B5 movups  [rbp+var_24], xmm0
.text:00000001400010B9 mov     [rbp+arg_0], rax
.text:00000001400010BD lea     rax, [rbp+var_34]
.text:00000001400010C1 mov     [rbp+arg_8], rax
```
Starting from `0x14000106B` to `0x14000106B` many instructions contain a `mov` operation, in which values get copied into memory locations (referenced by `[rbp + offset]`). 
```asm
[...]
.text:000000014000106B mov     [rbp+var_5C], 0B04EE3B8h
.text:0000000140001072 mov     [rbp+var_58], 0FEA7766Dh
.text:0000000140001079 mov     [rbp+var_54], 0E0B08383h
.text:0000000140001080 mov     [rbp+var_50], 1EF6C3A5h
.text:0000000140001087 mov     [rbp+var_4C], 19AB09B1h
.text:000000014000108E mov     [rbp+var_48], 0EEBB45CDh
.text:0000000140001095 mov     [rbp+var_44], 34FCA826h
.text:000000014000109C mov     [rbp+var_40], 2B0E76ACh
.text:00000001400010A3 mov     [rbp+var_3C], 50392963h
.text:00000001400010AA mov     [rbp+var_38], 5B1B5245h
[...]
```
This can also be seen in the generated psuedo C-code:
```C
[...]
 if ( byte_14007B170 )
    goto LABEL_8;
  v4[0] = 1820759598;
  v1 = -960092868;
  v4[1] = -1337007176;
  v4[2] = -22579603;
  v4[3] = -525302909;
  v4[4] = 519488421;
  v4[5] = 430639537;
  v4[6] = -289716787;
  v4[7] = 888973350;
  v4[8] = 722368172;
  v4[9] = 1345923427;
  v4[10] = 1528517189;
[...]
```
In the end another array (`v5` in the pseudo C-code) is filled with zeros. The C function `void *memset(void *str, int c, size_t n)` copies an integer (interpreted as an unsigned char) into the defined array (pointer `*str` to the memory block to fill), and also receiving the integer's size by the parameter `size_t`.
As seen in the pseudo C-code,
```C
[...]
memset(v5, 0, 44);
[...]
```
and the disassembly.
```asm
[...]
.text:00000001400010B1 movups  [rbp+var_34], xmm0
.text:00000001400010B5 movups  [rbp+var_24], xmm0
.text:00000001400010B9 mov     [rbp+arg_0], rax
.text:00000001400010BD lea     rax, [rbp+var_34]
.text:00000001400010C1 mov     [rbp+arg_8], rax
[...]
```
The control flow then reaches the basic block `0x1400010C5`






### [rax] != 6
If the condition is true, hence `[rax]` being not equal to `6`, a jump is taken from `0x140001027` to `0x140001131`:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/91b0c923-b6f9-4153-abd0-df13fcd56613" width="500">
<br/>

In here the register `al` is altered by an `xor    al, al` operation, which in addition also modifies the 64-bit register `rax` and 32-bit register `eax`.
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/044dad9e-607e-4dfd-b31b-df4bf3069bc0" width="400">
<br/>


### Basic Block at 0x140001133
Both branch sets finally reach the basic block at `0x140001133`. Some variables get written into the registers `r11`, `rbx` and `rdi` respectively. The stack is restored by copying the value of `r11` (`[rsp+80h+var_s0]`) into `rsp` and by popping `rbp`.
```asm
[...]
.text:0000000140001133
.text:0000000140001133 loc_140001133:
.text:0000000140001133 lea     r11, [rsp+80h+var_s0]
.text:000000014000113B mov     rbx, [r11+20h]
.text:000000014000113F mov     rdi, [r11+28h]
.text:0000000140001143 mov     rsp, r11
.text:0000000140001146 pop     rbp
.text:0000000140001147 retn
.text:0000000140001147 sub_140001000 endp
.text:0000000140001147
[...]
```
The function then returns.















@ fabio: 2do
## Type of Obfuscated Code
By looking further into the compiled pseudo-code, we are presented by the following:
```C
char sub_140001000()
{
  unsigned __int64 v0; // rdi
  int v1; // edx
  char v2; // dl
  char result; // al
  int v4[11]; // [rsp+20h] [rbp-60h]
  __int128 v5[3]; // [rsp+4Ch] [rbp-34h] BYREF

  v0 = 0i64;
  if ( MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270] != 1 )
    return 0;
  if ( byte_14007B170 )
    goto LABEL_8;
  v4[0] = 1820759598;
  v1 = -960092868;
  v4[1] = -1337007176;
  v4[2] = -22579603;
  v4[3] = -525302909;
  v4[4] = 519488421;
  v4[5] = 430639537;
  v4[6] = -289716787;
  v4[7] = 888973350;
  v4[8] = 722368172;
  v4[9] = 1345923427;
  v4[10] = 1528517189;
  memset(v5, 0, 44);
  do
  {
    v1 = __ROR4__(
           ((v1 ^ (unsigned int)(v1 << 13)) >> 7) ^ v1 ^ (v1 << 13) ^ ((((v1 ^ (unsigned int)(v1 << 13)) >> 7) ^ v1 ^ (v1 << 13)) << 17),
           4);
    *(_DWORD *)((char *)v5 + v0) = *(int *)((char *)v4 + v0) ^ v1;
    v0 += 4i64;
  }
  while ( v0 < 0x2C );
  LOBYTE(v0) = 1;
  if ( !sub_140008B54(v5) )
LABEL_8:
    v2 = 0;
  else
    v2 = 1;
  if ( (v0 & 1) != 0 )
    memset(v5, 0, 0x2Cui64);
  result = byte_14007B170;
  if ( v2 )
    result = 1;
  byte_14007B170 = result;
  return result;
}

```


@tim:
- possible arithemic encoding?
- amd x86 aufmachen? Intel oder AMD synthax? wahrscheinlich amd...
- 1152920920491294759 ??
- "byte_14007B170", was ist das? bytearray? ---> cmp bytearray, dil
- bspw. 000000014000106B: zahlen in int 




---
- Why does the rbx register not affect the value of the al register? - https://stackoverflow.com/questions/49958915/why-does-the-rbx-register-not-affect-the-value-of-the-al-register
- What does the x86-64 instruction "shrb %dil" mean? - https://stackoverflow.com/questions/41942502/what-does-the-x86-64-instruction-shrb-dil-mean
- C library function - memset() - https://www.tutorialspoint.com/c_standard_library/c_function_memset.htm
