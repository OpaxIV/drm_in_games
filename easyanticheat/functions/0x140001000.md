# Analysis of the Function at 0x140001000
## Graph View
To get a rough overview of the function, a look at the graph view is provided:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/f4bc1469-131c-4bb2-bf3e-ad2fe6733f11" width="500">
<br/>
As one can see, there are multiple branches (conditionals) which might be taken. There are basically two ways the control flow can go: Either by the "construction" on the left with the various conditional jumps, or the right side which is more or less a direct jump to the last basic block `0x140001133`.

## Control Flow Analysis & Disassembly
Besides the usual stack preparations, we can see a conditional jump at `0x140001027`. Either the value located in memory at `[rax]` is equal to `6` (hence the result being 6 - [rax] == 0) or not. A "more direct" jump would only occur if the result is not zero (`jnz     loc_140001131`).
```asm
[...]
.text:0000000140001000 mov     [rsp-8+arg_10], rbx
.text:0000000140001005 mov     [rsp-8+arg_18], rdi
.text:000000014000100A push    rbp
.text:000000014000100B mov     rbp, rsp
.text:000000014000100E sub     rsp, 80h
.text:0000000140001015 xor     edi, edi
.text:0000000140001017 mov     rax, 0FFFFF7800000026Ch
.text:0000000140001021 mov     dword ptr [rbp+arg_0], edi
.text:0000000140001024 cmp     dword ptr [rax], 6
.text:0000000140001027 jnz     loc_140001131
[...]
```
### [rax] == 6
The more complex path is taken, if `[rax]` is equal to the value`6`. 
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/1fa25bfc-51d5-435e-a32f-840455920967" width="500">
<br/>

The "false"-branch is executed, hence leading the path onto the address `0x14000102D`.
```asm
.text:000000014000102D mov     rax, 0FFFFF78000000270h
.text:0000000140001037 lea     ebx, [rdi+1]
.text:000000014000103A cmp     [rax], ebx
.text:000000014000103C jnz     loc_140001131
```
In here we can see that a rather large number `0x0FFFFF7800000027` (suffix removed) is being copied into the register `rax`. Converted into an integer this value would be interchangeable with `1152920920491294759`.
Afterwards some computation is executed by loading the effective address of `[rdi+1]` into `ebx`.
The value in register `ebx` is the compared to the location in memory at `[rax]`. If they do not compute to the same value, hence resulting in `ebx` - `[rax]` != 0, the control flow continues at the address `0x140001131`, the same as in the proceding outermost right branch:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/296e7c5d-bbeb-41d0-a03f-b70924d86f4d" width="500">
<br/>
On the other hand, if the opration `ebx` - `[rax]` is actually equal to zero, then the jump occurs into the following basic 






### [rax] != 6
If the condition is true, hence `[rax]` being not equal to `6`, a jump is taken from `0x140001027` to `0x140001131`:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/91b0c923-b6f9-4153-abd0-df13fcd56613" width="500">
<br/>

In here the register `al` is altered by an `xor    al, al` operation, which in addition also modifies the 64-bit register `rax` and 32-bit register `eax`.
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/044dad9e-607e-4dfd-b31b-df4bf3069bc0" width="400">
<br/>


### Basic Block at 0x140001133
Both branch sets finally reach the basic block at `0x140001133`. Some variables get written into the registers `r11`, `rbx` and `rdi` respectively. The stack is restored by copying the value of `r11` (`[rsp+80h+var_s0]`) into `rsp` and by popping `rbp`.
```asm
[...]
.text:0000000140001133
.text:0000000140001133 loc_140001133:
.text:0000000140001133 lea     r11, [rsp+80h+var_s0]
.text:000000014000113B mov     rbx, [r11+20h]
.text:000000014000113F mov     rdi, [r11+28h]
.text:0000000140001143 mov     rsp, r11
.text:0000000140001146 pop     rbp
.text:0000000140001147 retn
.text:0000000140001147 sub_140001000 endp
.text:0000000140001147
[...]
```
The function then returns.









## Type of Obfuscated Code
By looking further into the compiled pseudo-code, we are presented by the following:
```C
char sub_140001000()
{
  unsigned __int64 v0; // rdi
  int v1; // edx
  char v2; // dl
  char result; // al
  int v4[11]; // [rsp+20h] [rbp-60h]
  __int128 v5[3]; // [rsp+4Ch] [rbp-34h] BYREF

  v0 = 0i64;
  if ( MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270] != 1 )
    return 0;
  if ( byte_14007B170 )
    goto LABEL_8;
  v4[0] = 1820759598;
  v1 = -960092868;
  v4[1] = -1337007176;
  v4[2] = -22579603;
  v4[3] = -525302909;
  v4[4] = 519488421;
  v4[5] = 430639537;
  v4[6] = -289716787;
  v4[7] = 888973350;
  v4[8] = 722368172;
  v4[9] = 1345923427;
  v4[10] = 1528517189;
  memset(v5, 0, 44);
  do
  {
    v1 = __ROR4__(
           ((v1 ^ (unsigned int)(v1 << 13)) >> 7) ^ v1 ^ (v1 << 13) ^ ((((v1 ^ (unsigned int)(v1 << 13)) >> 7) ^ v1 ^ (v1 << 13)) << 17),
           4);
    *(_DWORD *)((char *)v5 + v0) = *(int *)((char *)v4 + v0) ^ v1;
    v0 += 4i64;
  }
  while ( v0 < 0x2C );
  LOBYTE(v0) = 1;
  if ( !sub_140008B54(v5) )
LABEL_8:
    v2 = 0;
  else
    v2 = 1;
  if ( (v0 & 1) != 0 )
    memset(v5, 0, 0x2Cui64);
  result = byte_14007B170;
  if ( v2 )
    result = 1;
  byte_14007B170 = result;
  return result;
}

```



@ tim: possible arithemic encoding?<br>
@ tim: 1152920920491294759 ??
@ tim: "byte_14007B170", was ist das? bytearray?



---
- Why does the rbx register not affect the value of the al register? - https://stackoverflow.com/questions/49958915/why-does-the-rbx-register-not-affect-the-value-of-the-al-register
- 
