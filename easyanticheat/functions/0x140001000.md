# Analysis of the Function at 0x140001000
## Graph View
To get a rough overview of the function, a look at the graph view is provided:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/f4bc1469-131c-4bb2-bf3e-ad2fe6733f11" width="500">
<br/>
As one can see, there are multiple branches (conditionals) which might be taken. There are basically two ways the control flow can go: Either by the "construction" on the left with the various conditional jumps, or the right side which is more or less a direct jump to the last basic block `0x140001133`.

## Detail Analysis of the Control Flow
Besides the usual stack preparations, we can see a conditional jump at `0x140001027`. Either the value located in memory at `[rax]` is equal to `6` (hence the result being 6 - [rax] == 0) or not. A "more direct" jump would only occur if the result is not zero (`jnz     loc_140001131`).
```asm
[...]
.text:0000000140001000 mov     [rsp-8+arg_10], rbx
.text:0000000140001005 mov     [rsp-8+arg_18], rdi
.text:000000014000100A push    rbp
.text:000000014000100B mov     rbp, rsp
.text:000000014000100E sub     rsp, 80h
.text:0000000140001015 xor     edi, edi
.text:0000000140001017 mov     rax, 0FFFFF7800000026Ch
.text:0000000140001021 mov     dword ptr [rbp+arg_0], edi
.text:0000000140001024 cmp     dword ptr [rax], 6
.text:0000000140001027 jnz     loc_140001131
[...]
```
### [rax] == 6
The more complex path is taken, if `[rax]` is equal to `6`. 
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/1fa25bfc-51d5-435e-a32f-840455920967" width="500">
<br/>




### [rax] != 6
If the condition is true, hence `[rax]` being not equal to `6`, a jump is taken from `0x140001027` to `0x140001131`:
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/91b0c923-b6f9-4153-abd0-df13fcd56613" width="500">
<br/>

In here the register `al` is altered by an `xor    al, al` operation, which in addition also modifies the 64-bit register `rax` and 32-bit register `eax`.
<br>
<img src="https://github.com/OpaxIV/hslu_secproj/assets/93701325/044dad9e-607e-4dfd-b31b-df4bf3069bc0" width="400">
<br/>


### Basic Block at 0x140001133
Both branch sets finally reach the basic block at `0x140001133`. Some variables get written into the registers `r11`, `rbx` and `rdi` respectively. The stack is restored by copying the value of `r11` (`[rsp+80h+var_s0]`) into `rsp` and by popping `rbp`.
```asm
[...]
.text:0000000140001133
.text:0000000140001133 loc_140001133:
.text:0000000140001133 lea     r11, [rsp+80h+var_s0]
.text:000000014000113B mov     rbx, [r11+20h]
.text:000000014000113F mov     rdi, [r11+28h]
.text:0000000140001143 mov     rsp, r11
.text:0000000140001146 pop     rbp
.text:0000000140001147 retn
.text:0000000140001147 sub_140001000 endp
.text:0000000140001147
[...]
```
The function then returns.


@ tim: possible arithemic encoding?



---
- Why does the rbx register not affect the value of the al register? - https://stackoverflow.com/questions/49958915/why-does-the-rbx-register-not-affect-the-value-of-the-al-register
- 
